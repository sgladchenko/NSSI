#!/usr/bin/env python3

import numpy as np
import os, sys, json, argparse

from Data import Data
from Modules import FourPlots1D, OnePlot2D_EPS

# The labels that are connected to the solution curves and 2d-plots
legendlabels = [r"$\nu_e$", r"$\nu_x$", r"$\bar{\nu}_e$", r"$\bar{\nu}_x$"]
filelabels   = ["eNu", "xNu", "eANu", "xANu"]

# Help messages
help_dir = "Specifies the directory in which the desired data is located. "\
           "This folder must consist of a subfolder 'bin' (and the binary files "\
           "left.bin and right.bin inside) and the files containing the points "\
           "of grids 'XGrid.txt' and 'ZGrid.txt'. "\
           "Such folders are auto-generated by the main executable 'nssi' while dumping the "\
           "numerical data of solutions."

help_periodN_x = "Specifies a step (or increment) of the visualised indices along x axis. "\
                 "That is quite handy when operating very large binary datasets for which "\
                 "we do not need so many points while visualising the solution at the plots. "\
                 "The value of periodN_x must be a divisor of the real saved grid's dimension. "\
                 "That means e.g. when 501 points are saved, --periodN_x=13 will be improper, "\
                 "while --periodN_x=10 is OK, because 10 is a divisor of 500 (the length of "\
                 "the saved grid but with the last point excluded, because this is just a copy "\
                 "of the very first point)."

help_periodN_z = "Same as --periodN_x, but along z axis."

if __name__ == "__main__":
    # A little bit of parsing command line arguments, including auto generated help page
    parser = argparse.ArgumentParser(description="Loads binary data, makes the plots and saves additional numerical data.")
    parser.add_argument("--dir", help=help_dir)
    parser.add_argument("--periodN_x", default=1, help=help_periodN_x, type=int)
    parser.add_argument("--periodN_z", default=1, help=help_periodN_z, type=int)
    parser.add_argument("--noplots", action='store_true')
    args = parser.parse_args()
    
    # The arguments themselves
    dir       = args.dir
    periodN_x = args.periodN_x
    periodN_z = args.periodN_z
    noplots   = args.noplots

    # The main object that handles the files put in the setup folder
    data = Data(folder=dir, periodN_x=periodN_x, periodN_z=periodN_z)

    """ Section: draw the plots """

    if not noplots:
        # Firsly, let's load the binaries
        data.LoadBin()
        # Make a directory of plots if it doesn't exist
        if not os.path.isdir(f"{dir}/plots"): os.mkdir(f"{dir}/plots")
        # The filenames of plots to be generated; all of them here are in the encapsulated postscript (eps)
        filenames = [f"{each}L.eps" for each in filelabels] + [f"{each}R.eps" for each in filelabels]
        for i in range(8):
            OnePlot2D_EPS(data.XGrid_displayed, data.ZGrid_displayed, data.Probabilities[i], f"{dir}/plots/{filenames[i]}")

    """ Section: cook the average probabilities, save them and plot """

    # Firsly, let's obtain these average values; and in case we haven't loaded the binaries
    # let's use 'lazy' generator
    if noplots: data.LazyEvaluateAverages()
    else:       data.EvaluateAverages()

    # Then, let's dump these values
    data.DumpAverages()
    # And finally, make the plots
    FourPlots1D(data.ZGrid_displayed, data.Averages[:4], f"{dir}/plots/avsL.eps", legendlabels)
    FourPlots1D(data.ZGrid_displayed, data.Averages[4:], f"{dir}/plots/avsR.eps", legendlabels)
    